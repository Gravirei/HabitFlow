/**
 * AI Insights Engine - Core Analysis Algorithms
 * 100% Client-Side Pattern Recognition & Statistical Analysis
 */

import { 
  AIInsights, 
  TimerSessionData, 
  PeakHoursInsight,
  DurationPatternInsight,
  ModeMasteryInsight,
  ConsistencyInsight,
  ProductivityTrendInsight,
  ProductivityScore,
  WeeklySummary
} from './types'

/**
 * Main function to generate AI insights from timer sessions
 */
export function generateAIInsights(sessions: TimerSessionData[]): AIInsights {
  const now = new Date()
  const dataQuality = determineDataQuality(sessions)
  
  // Sort sessions by start time
  const sortedSessions = [...sessions].sort((a, b) => 
    new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
  )

  const dataRange = {
    start: sortedSessions.length > 0 ? new Date(sortedSessions[0].startTime) : now,
    end: sortedSessions.length > 0 ? new Date(sortedSessions[sortedSessions.length - 1].endTime) : now,
    sessionsAnalyzed: sessions.length
  }

  return {
    generatedAt: now,
    dataRange,
    productivityScore: calculateProductivityScore(sessions),
    peakHours: sessions.length >= 5 ? analyzePeakHours(sessions) : undefined,
    durationPattern: sessions.length >= 5 ? analyzeDurationPatterns(sessions) : undefined,
    modeMastery: sessions.length >= 10 ? analyzeModeMastery(sessions) : undefined,
    consistency: analyzeConsistency(sessions),
    productivityTrend: sessions.length >= 10 ? analyzeProductivityTrend(sessions) : undefined,
    recommendations: [],  // Will be populated by insightGenerators
    weeklySummary: generateWeeklySummary(sessions),
    dataQuality
  }
}

/**
 * Determine data quality based on session count
 */
function determineDataQuality(sessions: TimerSessionData[]): 'insufficient' | 'limited' | 'good' | 'excellent' {
  const count = sessions.length
  if (count < 5) return 'insufficient'
  if (count < 20) return 'limited'
  if (count < 50) return 'good'
  return 'excellent'
}

/**
 * Analyze peak productivity hours
 */
export function analyzePeakHours(sessions: TimerSessionData[]): PeakHoursInsight {
  // Initialize hourly distribution
  const hourlyStats = Array.from({ length: 24 }, (_, hour) => ({
    hour,
    sessions: 0,
    duration: 0,
    completed: 0,
    total: 0
  }))

  // Aggregate data by hour
  sessions.forEach(session => {
    const hour = new Date(session.startTime).getHours()
    hourlyStats[hour].sessions++
    hourlyStats[hour].duration += session.duration
    hourlyStats[hour].total++
    if (session.completed) {
      hourlyStats[hour].completed++
    }
  })

  // Find 3-hour peak window
  let maxScore = 0
  let peakStart = 9  // Default 9 AM

  for (let i = 0; i < 24; i++) {
    const window = [i, (i + 1) % 24, (i + 2) % 24]
    const score = window.reduce((sum, h) => sum + hourlyStats[h].sessions, 0)
    
    if (score > maxScore) {
      maxScore = score
      peakStart = i
    }
  }

  const peakEnd = (peakStart + 3) % 24
  const peakHours = [peakStart, (peakStart + 1) % 24, (peakStart + 2) % 24]
  const peakData = peakHours.map(h => hourlyStats[h])
  
  const peakSessions = peakData.reduce((sum, h) => sum + h.sessions, 0)
  const peakDuration = peakData.reduce((sum, h) => sum + h.duration, 0)
  const peakCompleted = peakData.reduce((sum, h) => sum + h.completed, 0)
  const peakTotal = peakData.reduce((sum, h) => sum + h.total, 0)

  const hourlyDistribution = hourlyStats.map(h => ({
    hour: h.hour,
    sessions: h.sessions,
    duration: h.duration,
    completionRate: h.total > 0 ? (h.completed / h.total) * 100 : 0
  }))

  const confidence = sessions.length >= 20 ? 'high' : sessions.length >= 10 ? 'medium' : 'low'
  const completionRate = peakTotal > 0 ? (peakCompleted / peakTotal) * 100 : 0

  return {
    type: 'peak-hours',
    peakWindow: {
      startHour: peakStart,
      endHour: peakEnd,
      sessionsCount: peakSessions,
      totalDuration: peakDuration,
      completionRate
    },
    hourlyDistribution,
    message: '', // Will be generated by insightGenerators
    confidence
  }
}

/**
 * Analyze session duration patterns
 */
export function analyzeDurationPatterns(sessions: TimerSessionData[]): DurationPatternInsight {
  // Duration buckets: <5min, 5-15min, 15-30min, 30-60min, >60min
  const buckets = [
    { range: '<5min', min: 0, max: 300, count: 0, completed: 0, total: 0 },
    { range: '5-15min', min: 300, max: 900, count: 0, completed: 0, total: 0 },
    { range: '15-30min', min: 900, max: 1800, count: 0, completed: 0, total: 0 },
    { range: '30-60min', min: 1800, max: 3600, count: 0, completed: 0, total: 0 },
    { range: '>60min', min: 3600, max: Infinity, count: 0, completed: 0, total: 0 }
  ]

  sessions.forEach(session => {
    const bucket = buckets.find(b => session.duration >= b.min && session.duration < b.max)
    if (bucket) {
      bucket.count++
      bucket.total++
      if (session.completed) bucket.completed++
    }
  })

  // Find optimal duration range (highest completion rate with significant count)
  const validBuckets = buckets.filter(b => b.count >= 3)
  const optimalBucket = validBuckets.length > 0
    ? validBuckets.reduce((best, current) => {
        const currentRate = current.completed / current.total
        const bestRate = best.completed / best.total
        return currentRate > bestRate ? current : best
      })
    : buckets[2] // Default to 15-30min

  const avgDuration = sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length

  // Determine trend
  const recentSessions = sessions.slice(-10)
  const olderSessions = sessions.slice(0, Math.min(10, sessions.length - 10))
  const recentAvg = recentSessions.reduce((sum, s) => sum + s.duration, 0) / recentSessions.length
  const olderAvg = olderSessions.length > 0 
    ? olderSessions.reduce((sum, s) => sum + s.duration, 0) / olderSessions.length 
    : recentAvg

  const trend = recentAvg > olderAvg * 1.1 ? 'increasing' 
    : recentAvg < olderAvg * 0.9 ? 'decreasing' 
    : 'stable'

  const confidence = sessions.length >= 20 ? 'high' : sessions.length >= 10 ? 'medium' : 'low'

  return {
    type: 'duration-pattern',
    optimalDuration: {
      min: optimalBucket.min,
      max: optimalBucket.max,
      avgDuration,
      completionRate: (optimalBucket.completed / optimalBucket.total) * 100
    },
    durationBuckets: buckets.map(b => ({
      range: b.range,
      count: b.count,
      completionRate: b.total > 0 ? (b.completed / b.total) * 100 : 0
    })),
    trend,
    message: '',
    confidence
  }
}

/**
 * Analyze mode mastery (which timer mode works best)
 */
export function analyzeModeMastery(sessions: TimerSessionData[]): ModeMasteryInsight {
  const modeStats = {
    Stopwatch: { sessions: 0, duration: 0, completed: 0, total: 0 },
    Countdown: { sessions: 0, duration: 0, completed: 0, total: 0 },
    Intervals: { sessions: 0, duration: 0, completed: 0, total: 0 }
  }

  sessions.forEach(session => {
    const stats = modeStats[session.mode]
    stats.sessions++
    stats.duration += session.duration
    stats.total++
    if (session.completed) stats.completed++
  })

  // Find best mode (highest completion rate with significant usage)
  const modes = Object.entries(modeStats)
    .filter(([_, stats]) => stats.sessions >= 3)
    .map(([mode, stats]) => ({
      mode: mode as 'Stopwatch' | 'Countdown' | 'Intervals',
      ...stats,
      completionRate: stats.completed / stats.total,
      avgDuration: stats.duration / stats.sessions
    }))

  const bestMode = modes.length > 0
    ? modes.reduce((best, current) => 
        current.completionRate > best.completionRate ? current : best
      )
    : { mode: 'Stopwatch' as const, sessions: 0, duration: 0, completed: 0, total: 0, completionRate: 0, avgDuration: 0 }

  const modeComparison = Object.entries(modeStats).map(([mode, stats]) => ({
    mode: mode as 'Stopwatch' | 'Countdown' | 'Intervals',
    sessions: stats.sessions,
    duration: stats.duration,
    completionRate: stats.total > 0 ? (stats.completed / stats.total) * 100 : 0
  }))

  const confidence = sessions.length >= 30 ? 'high' : sessions.length >= 15 ? 'medium' : 'low'

  return {
    type: 'mode-mastery',
    bestMode: {
      mode: bestMode.mode,
      sessionsCount: bestMode.sessions,
      totalDuration: bestMode.duration,
      completionRate: bestMode.completionRate * 100,
      avgDuration: bestMode.avgDuration
    },
    modeComparison,
    message: '',
    confidence
  }
}

/**
 * Analyze consistency metrics
 */
export function analyzeConsistency(sessions: TimerSessionData[]): ConsistencyInsight {
  if (sessions.length === 0) {
    return {
      type: 'consistency',
      score: 0,
      metrics: {
        activeDays: 0,
        totalDays: 0,
        currentStreak: 0,
        longestStreak: 0,
        avgSessionsPerDay: 0,
        regularityScore: 0
      },
      message: '',
      trend: 'stable'
    }
  }

  const sortedSessions = [...sessions].sort((a, b) => 
    new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
  )

  const firstDate = new Date(sortedSessions[0].startTime)
  const lastDate = new Date(sortedSessions[sortedSessions.length - 1].startTime)
  const totalDays = Math.ceil((lastDate.getTime() - firstDate.getTime()) / (1000 * 60 * 60 * 24)) + 1

  // Count active days
  const activeDaysSet = new Set<string>()
  sortedSessions.forEach(session => {
    const dateKey = new Date(session.startTime).toDateString()
    activeDaysSet.add(dateKey)
  })
  const activeDays = activeDaysSet.size

  // Calculate streaks
  const dateKeys = Array.from(activeDaysSet).sort()
  let currentStreak = 0
  let longestStreak = 0
  let tempStreak = 1

  const today = new Date().toDateString()
  const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString()
  
  if (dateKeys.includes(today) || dateKeys.includes(yesterday)) {
    currentStreak = 1
    let checkDate = dateKeys.includes(today) ? new Date() : new Date(Date.now() - 24 * 60 * 60 * 1000)
    
    while (true) {
      checkDate.setDate(checkDate.getDate() - 1)
      const checkKey = checkDate.toDateString()
      if (dateKeys.includes(checkKey)) {
        currentStreak++
      } else {
        break
      }
    }
  }

  for (let i = 1; i < dateKeys.length; i++) {
    const prevDate = new Date(dateKeys[i - 1])
    const currDate = new Date(dateKeys[i])
    const daysDiff = Math.ceil((currDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24))
    
    if (daysDiff === 1) {
      tempStreak++
      longestStreak = Math.max(longestStreak, tempStreak)
    } else {
      tempStreak = 1
    }
  }
  longestStreak = Math.max(longestStreak, tempStreak)

  const avgSessionsPerDay = sessions.length / activeDays

  const dailySessionCounts: number[] = []
  activeDaysSet.forEach(dateKey => {
    const count = sortedSessions.filter(s => 
      new Date(s.startTime).toDateString() === dateKey
    ).length
    dailySessionCounts.push(count)
  })

  const avgSessions = dailySessionCounts.reduce((sum, c) => sum + c, 0) / dailySessionCounts.length
  const variance = dailySessionCounts.reduce((sum, c) => sum + Math.pow(c - avgSessions, 2), 0) / dailySessionCounts.length
  const stdDev = Math.sqrt(variance)
  const coefficientOfVariation = avgSessions > 0 ? (stdDev / avgSessions) : 0
  const regularityScore = Math.max(0, Math.min(100, (1 - coefficientOfVariation) * 100))

  const activeDaysRatio = activeDays / Math.max(totalDays, 1)
  const streakScore = Math.min(currentStreak / 30, 1)
  const consistencyScore = Math.round(
    activeDaysRatio * 50 + streakScore * 25 + regularityScore * 0.25
  )

  const recentDays = 7
  const recentCutoff = new Date(Date.now() - recentDays * 24 * 60 * 60 * 1000)
  const recentSessions = sortedSessions.filter(s => new Date(s.startTime) >= recentCutoff)
  const olderSessions = sortedSessions.filter(s => new Date(s.startTime) < recentCutoff)
  
  const recentAvg = recentSessions.length / recentDays
  const olderAvg = olderSessions.length / Math.max(totalDays - recentDays, 1)
  
  const trend = recentAvg > olderAvg * 1.2 ? 'improving' 
    : recentAvg < olderAvg * 0.8 ? 'declining' 
    : 'stable'

  return {
    type: 'consistency',
    score: consistencyScore,
    metrics: {
      activeDays,
      totalDays,
      currentStreak,
      longestStreak,
      avgSessionsPerDay,
      regularityScore
    },
    message: '',
    trend
  }
}

/**
 * Analyze productivity trends
 */
export function analyzeProductivityTrend(sessions: TimerSessionData[]): ProductivityTrendInsight {
  const now = Date.now()
  const weekMs = 7 * 24 * 60 * 60 * 1000
  
  const currentWeekSessions = sessions.filter(s => 
    new Date(s.startTime).getTime() >= now - weekMs
  )
  const previousWeekSessions = sessions.filter(s => {
    const time = new Date(s.startTime).getTime()
    return time >= now - (2 * weekMs) && time < now - weekMs
  })

  const current = {
    sessions: currentWeekSessions.length,
    duration: currentWeekSessions.reduce((sum, s) => sum + s.duration, 0),
    completionRate: currentWeekSessions.length > 0
      ? (currentWeekSessions.filter(s => s.completed).length / currentWeekSessions.length) * 100
      : 0
  }

  const previous = {
    sessions: previousWeekSessions.length,
    duration: previousWeekSessions.reduce((sum, s) => sum + s.duration, 0),
    completionRate: previousWeekSessions.length > 0
      ? (previousWeekSessions.filter(s => s.completed).length / previousWeekSessions.length) * 100
      : 0
  }

  const change = {
    sessions: previous.sessions > 0 
      ? ((current.sessions - previous.sessions) / previous.sessions) * 100 
      : 0,
    duration: previous.duration > 0 
      ? ((current.duration - previous.duration) / previous.duration) * 100 
      : 0,
    completionRate: previous.completionRate > 0 
      ? ((current.completionRate - previous.completionRate) / previous.completionRate) * 100 
      : 0
  }

  const avgChange = (change.sessions + change.duration + change.completionRate) / 3
  const trend = avgChange > 10 ? 'up' : avgChange < -10 ? 'down' : 'stable'

  return {
    type: 'productivity-trend',
    currentPeriod: current,
    previousPeriod: previous,
    change,
    trend,
    message: ''
  }
}

/**
 * Calculate overall productivity score
 */
export function calculateProductivityScore(sessions: TimerSessionData[]): ProductivityScore {
  if (sessions.length === 0) {
    return {
      overall: 0,
      breakdown: {
        consistency: 0,
        duration: 0,
        completion: 0,
        frequency: 0,
        improvement: 0
      },
      grade: 'F',
      message: ''
    }
  }

  const consistency = analyzeConsistency(sessions)
  const consistencyScore = consistency.score

  const avgDuration = sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length
  const optimalMin = 15 * 60
  const optimalMax = 45 * 60
  let durationScore = 0
  if (avgDuration >= optimalMin && avgDuration <= optimalMax) {
    durationScore = 100
  } else if (avgDuration < optimalMin) {
    durationScore = (avgDuration / optimalMin) * 100
  } else {
    durationScore = Math.max(0, 100 - ((avgDuration - optimalMax) / optimalMax) * 50)
  }

  const completedCount = sessions.filter(s => s.completed).length
  const completionScore = (completedCount / sessions.length) * 100

  const firstDate = new Date(sessions[0].startTime)
  const lastDate = new Date(sessions[sessions.length - 1].startTime)
  const weeks = Math.max(1, (lastDate.getTime() - firstDate.getTime()) / (7 * 24 * 60 * 60 * 1000))
  const sessionsPerWeek = sessions.length / weeks
  const frequencyScore = Math.min(100, (sessionsPerWeek / 7) * 100)

  const recentSessions = sessions.slice(-10)
  const olderSessions = sessions.slice(0, Math.min(10, sessions.length - 10))
  const recentCompletion = recentSessions.filter(s => s.completed).length / recentSessions.length
  const olderCompletion = olderSessions.length > 0 
    ? olderSessions.filter(s => s.completed).length / olderSessions.length 
    : recentCompletion
  const improvementScore = Math.min(100, Math.max(0, 50 + ((recentCompletion - olderCompletion) * 100)))

  const overall = Math.round(
    consistencyScore * 0.30 +
    durationScore * 0.20 +
    completionScore * 0.25 +
    frequencyScore * 0.15 +
    improvementScore * 0.10
  )

  let grade: 'A+' | 'A' | 'B' | 'C' | 'D' | 'F'
  if (overall >= 95) grade = 'A+'
  else if (overall >= 85) grade = 'A'
  else if (overall >= 70) grade = 'B'
  else if (overall >= 55) grade = 'C'
  else if (overall >= 40) grade = 'D'
  else grade = 'F'

  return {
    overall,
    breakdown: {
      consistency: Math.round(consistencyScore),
      duration: Math.round(durationScore),
      completion: Math.round(completionScore),
      frequency: Math.round(frequencyScore),
      improvement: Math.round(improvementScore)
    },
    grade,
    message: ''
  }
}

/**
 * Generate weekly summary
 */
export function generateWeeklySummary(sessions: TimerSessionData[]): WeeklySummary {
  const now = new Date()
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
  
  const weeklySessions = sessions.filter(s => 
    new Date(s.startTime) >= weekAgo
  )

  if (weeklySessions.length === 0) {
    return {
      period: { start: weekAgo, end: now },
      highlights: {
        totalSessions: 0,
        totalDuration: 0,
        activeDays: 0,
        completionRate: 0,
        mostProductiveDay: { date: now, sessions: 0, duration: 0 },
        longestSession: { duration: 0, date: now, mode: 'Stopwatch' }
      },
      message: ''
    }
  }

  const totalDuration = weeklySessions.reduce((sum, s) => sum + s.duration, 0)
  const completionRate = (weeklySessions.filter(s => s.completed).length / weeklySessions.length) * 100

  const activeDaysSet = new Set<string>()
  weeklySessions.forEach(s => activeDaysSet.add(new Date(s.startTime).toDateString()))
  const activeDays = activeDaysSet.size

  const dayStats = new Map<string, { sessions: number; duration: number }>()
  weeklySessions.forEach(s => {
    const dateKey = new Date(s.startTime).toDateString()
    const stats = dayStats.get(dateKey) || { sessions: 0, duration: 0 }
    stats.sessions++
    stats.duration += s.duration
    dayStats.set(dateKey, stats)
  })

  let mostProductiveDay = { date: now, sessions: 0, duration: 0 }
  dayStats.forEach((stats, dateKey) => {
    if (stats.duration > mostProductiveDay.duration) {
      mostProductiveDay = {
        date: new Date(dateKey),
        sessions: stats.sessions,
        duration: stats.duration
      }
    }
  })

  const longest = weeklySessions.reduce((max, s) => 
    s.duration > max.duration ? s : max
  , weeklySessions[0])

  return {
    period: { start: weekAgo, end: now },
    highlights: {
      totalSessions: weeklySessions.length,
      totalDuration,
      activeDays,
      completionRate,
      mostProductiveDay,
      longestSession: {
        duration: longest.duration,
        date: new Date(longest.startTime),
        mode: longest.mode
      }
    },
    message: ''
  }
}
